%% Prepare The Environment
close all; clear all;%fresh slate
addpath('Utilities');%functions go into utilities folder
addpath('Data Structs');%structs go into this folder

%% Setting Up The Workspace And User Preferences
% Change this function to change simulation parameters
% Set parameters here you don't want to iterate over, that happens below
SystemParam = setupSystemParams();

% Set to 1 to save generated results to excel file, set to 0 otherwise
writeToFile = 1;   

% If set to 1, each iteration will ding
sound = 0;

% Set a valid writable filename, and display to output
filename = fullfile(pwd, 'data', 'output.xlsx');
disp(filename)

% Set excel sheet number to write to
sheetNum=1;

%% Define Iteration Parameters and Metadata

% Use standard SystemParams
iterParamsStandard = struct( ...
    'fiberRadius', SystemParam.fiberRadius, ...
    'xLen', SystemParam.xLen, ...
    'ledDistance', SystemParam.ledDistance, ...
    'nFiber', SystemParam.n1, ...
    'nMetal', SystemParam.nMetal, ...
    'ray_sqrt', SystemParam.angleNum, ...
    'scatterNumber', SystemParam.scatterNum, ...
    'dxNum', SystemParam.contDx, ...
    'intensityMin', SystemParam.intensityMin, ...
    'smaNum', SystemParam.housingBounce, ...
    'maxScatterAngle', SystemParam.maxScatterAngle, ...
    'maxBounce', SystemParam.maxBounce, ...
    'rayScatterCoeff', SystemParam.rayScatterCoeff, ...
    'smaFillLength', SystemParam.smaFillLength, ...
    'waterStatus', SystemParam.waterInterface);

% Define your own, iterable, version
iterParamsCustom = struct( ...
    'fiberRadius', [125,200], ...
    'xLen', ([10,20,30]+2)*10^4, ... %cm->[um]
    'ledDistance', SystemParam.ledDistance, ...
    'nFiber', SystemParam.n1, ...
    'nMetal', SystemParam.nMetal, ...
    'ray_sqrt', SystemParam.angleNum, ...
    'scatterNumber', SystemParam.scatterNum, ...
    'dxNum', SystemParam.contDx, ...
    'intensityMin', SystemParam.intensityMin, ...
    'smaNum', SystemParam.housingBounce, ...
    'maxScatterAngle', SystemParam.maxScatterAngle, ...
    'maxBounce', SystemParam.maxBounce, ...
    'rayScatterCoeff', SystemParam.rayScatterCoeff, ...
    'smaFillLength', SystemParam.smaFillLength, ...
    'waterStatus', SystemParam.waterInterface);

iterParams = iterParamsCustom;

paramNames = fieldnames(iterParams);
paramLengths = cellfun(@(f) length(iterParams.(f)), paramNames);
iterVars = find(paramLengths > 1);

% Check number of varying parameters
if isempty(iterVars)
    it_name = ' ';
    yes_itname = 0;
    legendMain = ' ';
    Title_Main = generateTitle(SystemParam);
elseif length(iterVars) > 1
    % Multiple parameters vary â€” full grid
    [gridStruct, it_num] = generateParameterGrid(iterParams);
    legendMain = generateLegends(gridStruct, paramNames(iterVars));
    yes_itname = 2;
    Title_Main = generateTitle(SystemParam);

    % Flatten grid to update iterParams values
    for i = 1:length(iterVars)
        name = paramNames{iterVars(i)};
        iterParams.(name) = gridStruct.(name);
    end
else
    % Only one parameter is being iterated
    varName = paramNames{iterVars};
    values = iterParams.(varName);
    it_name = getDisplayName(varName);
    yes_itname = 1;
    Title_Main = generateTitle(SystemParam);
    legendMain = arrayfun(@(v) formatLegend(varName, v), values, 'UniformOutput', false);
    legendMain = string(legendMain);
end

description = autoGenerateDescription(iterParams);

%% Setting Up The Simulation
% Set up smoothing parameters
numRandomIters = 1;  % Future: Set dynamically if using random inputs
% Consider adding a SystemParam field like: SystemParam.smoothingLevel

% Access core simulation data
ray    = Ray;             % Individual rays
trial = randomTrial;         % Random trials
FibIt   = Fib_It;         % Fiber iteration data
SumVal  = SummaryVals;    % All ray data (cell)
Tally   = Tracking;       % Diagnostic tracking
meas    = Measure_Instant;% Instantaneous measurements
IT      = travel_storage; % Temporary loss storage

% Initialize output arrays
fields = ["Pow_enter", "transmitted", "pow_side", "pow_side_use", ...
          "SMA_pow_side", "pow_side_waterst", "absorbed", "backscat", ...
          "SMAabs", "approxpow_dif", "approxpow_pos", "b2hpow", ...
          "cutoffpow", "remaininglosses", "UC", "RatioIsIt"];
for f = fields
    FibIt(1).(f) = zeros(it_num, SystemParam.numFibers);
    FibIt(2).(f) = zeros(it_num, SystemParam.numFibers);
end
FibIt(1).Y = cell(it_num, SystemParam.numFibers);
FibIt(2).Y = cell(it_num, SystemParam.numFibers);

%% Main iteration loop
for iteration = 1:it_num
    % Reset fiberRadius each loop in case it's overwritten
    fiberRadius = SystemParam.fiberRadius;

    % Apply parameter overrides for each iteration case
    if yes_itname == 1
        val = iteration;
        switch index_it
            case 1,  SystemParam.fiberRadius     = fiberRadius(val);
                     fiberRadius                 = SystemParam.fiberRadius;
            case 2,  SystemParam.xLen            = xLen(val);
            case 3,  SystemParam.ledDistance     = ledDistance(val);
            case 4,  SystemParam.n1              = nFiber(val);
            case 5,  SystemParam.nMetal          = nMetal(val);
            case 6,  SystemParam.angleNum        = ray_sqrt(val);
                     SystemParam.numLedRays      = ray_sqrt(val)^2;
                     SystemParam.scatterNum      = ray_sqrt(val);
            case 7,  SystemParam.scatterNum      = scatterNumber(val);
            case 8,  SystemParam.contDx          = dxNum(val);
            case 9,  SystemParam.intensityMin    = intensityMin(val);
            case 10, SystemParam.housingBounce   = smaNum(val);
            case 11, SystemParam.maxScatterAngle = maxScatterAngle(val);
            case 12, SystemParam.maxBounce       = maxBounce(val);
            case 13, SystemParam.rayScatterCoeff = rayScatterCoeff(val);
            case 14, SystemParam.smaFillLength   = smaFillLength(val);
            case 15, SystemParam.waterInterface  = waterStatus(val);
            otherwise, error('Unhandled parameter index_it = %d', index_it);
        end
    elseif yes_itname == 2
        % Multiple parameters vary
        SystemParam.maxScatterAngle = gridStruct(iteration).maxScatterAngle; 
        SystemParam.rayScatterCoeff = gridStruct(iteration).rayScatterCoeff;
        SystemParam.n1              = gridStruct(iteration).nFiber;
        SystemParam.nMetal          = gridStruct(iteration).nMetal;
        SystemParam.waterInterface  = gridStruct(iteration).waterStatus;
        SystemParam.scatterNum      = gridStruct(iteration).scatterNumber;
        SystemParam.smaFillLength   = gridStruct(iteration).smaFillLength;
        SystemParam.xLen            = gridStruct(iteration).xLen;
        
        % Special rule for sealed SMA connectors
        if SystemParam.xLen >= 48.5e4
            SystemParam.isSmaSealed = 1;
        else
            SystemParam.isSmaSealed = 0;
        end
    end


    %calculate parameters that may need to use the changed iteration system
    SystemParam.alpha=(10^-6)*(imag(SystemParam.n1)*4*pi/(SystemParam.uvWavelength*10^-9))*10/log(10);%db/um overall absorption coefficient
    % SystemParam.uvAlpha=alpha*(1-rayScatterCoeff);%db/um %ub absorption coeff
    % SystemParam.rayleighAlpha=alpha*rayScatterCoeff;%db/um %rayleigh scattering absorption coefficient
    Xvec=0:(SystemParam.division/10e3):(SystemParam.xLen/10e3);

    %%%%%%%setting up information for req number of random loops%%%%
    %include if/then surface roughness/NP randomness and such statements
    %statements%%%%%%%%%%%%
    
    %%%%% create the boundary struct for a glass fiber%%%%%%%
    Bounds = Bound;
    Bounds.Pf0=[0,SystemParam.fiberRadius];%boundary at starting position
    Bounds.Pfe=[SystemParam.xLen,SystemParam.fiberRadius];%boundary at ending position
    
    %%Uniformity coefficient index set up for later calculation
    i1=round((((SystemParam.xLen/10000)-1)/(SystemParam.division*10^-4))*(0.1))+1;
    i6=round((((SystemParam.xLen/10000)-2)/(SystemParam.division*10^-4))*(0.6))+1;
    
    
    %set up of incoming ray angle, intensity, for a variable number of fibers
    LED_d=SystemParam.ledDistance;%(um)%LED distance in um for Entering Light
    [Ray_X,Ray_Y,alpha_ang,beta_ang,Power_mat] = OutputLED3D(SystemParam);
    powercheck=sum(Power_mat,'all')*(SystemParam.ledDiameter*10^-1)^2;% make sure power isn't greater than the total LED power
    %determining light rays entering each fiber
    [circles,combocircles] = fiberBundle3D(SystemParam.numFibers,fiberRadius*2);
    %[Ent_Int,Theta,y0,perc_hit,perc_ent,Entering_Int,Entering_angle,Entering_X,Entering_Y,incoming_int,incoming_ang] = enterLight3D_AINsubstrate(SystemParam,fiberRadius, LED_d,alpha_ang,beta_ang,Ray_X,Ray_Y,Intensity_mat,circles);
    [Ent_Int,Theta,y0,perc_hit,perc_ent,Entering_Int,Entering_angle,Entering_X,Entering_Y,incoming_int,incoming_ang] = enterLight3D(SystemParam,fiberRadius, LED_d,alpha_ang,beta_ang,Ray_X,Ray_Y,Power_mat,circles);
    %compressed to 2D
    %Ent_Int=Ent_Int;
    [a,b,c]=size(Ent_Int); %[num ang changes,num y locations, number fibers]

    Tally = initializeTally(it_num, SystemParam, numRandomIters, a, b);

    %within each individual fiber
    for h=1:c%%%%%%include for number fiber change
        %empty storage for each numRandomIters
        [ray, trial] = initializeTrial(a, b, numRandomIters);

        %tracking and summmation values for each fiber
        for aa=1:numRandomIters
            %include surface roughness distribution
            %include NP distribution
            for xx=1:a
                for yy=1:b
                   %dont need to bother iterating through no intensity
                   if Ent_Int(xx,yy,h)==0
                       continue
                   end

                    %measurement storage vectors
                    meas.points= zeros(2*10e6,2);
                    meas.inten = zeros(2*10e6,1);
                    meas.counter=1;
                    meas.sum=0;
                    
                    Global_Index=[iteration,h,aa,xx,yy];%record the index values, may need to include a gg if scatter cone at the front
                    Y_sum=zeros(size(Xvec));
                    %create a scatter cone
                    if SystemParam.frontScatter==1
                        [I_scatter,Theta_enter]=scatter_cone(SystemParam,Theta(xx,yy,h),1);
                        I_enter=I_scatter.*Ent_Int(xx,yy,h);
                        gg_max=length(I_scatter);
                    else
                        I_enter=Ent_Int(xx,yy,h);
                        Theta_enter=Theta(xx,yy,h);
                        gg_max=1;
                    end
                    %tracking and summing values for each ray
                    %temporary storage of data
                    [ray, meas, MEAS0] = runSimulation(SystemParam, ray, meas, Bounds, Global_Index, Tally, ...
                                        gg_max, I_enter, Theta_enter, ...
                                        aa, xx, yy, h, y0);

                    ray.pow_side(aa,xx,yy)=sum(meas.inten)-MEAS0;

                    total_pow_use=[ray.pow_side(aa,xx,yy),ray.transmitted(aa,xx,yy),...
                                ray.SMAabs(aa,xx,yy),ray.b2hpow(aa,xx,yy),...
                                ray.backscat(aa,xx,yy),ray.absorbed(aa,xx,yy),ray.cutoffpow(aa,xx,yy)];
                
                    % Tracking differences
                    % [Tally,Differenceamount,Diffamountpos] =  DifTrack(ray.Pow_enter(aa,xx,yy),total_pow_use,SystemParam,'total while loop',0,Global_Index,Tally);
                    % ray.remaininglosses(aa,xx,yy)=Differenceamount;

                    %store measured data
                    %only include values that exist
                    indexes=find(meas.inten);
                    ray.meas_inten(aa,xx,yy)={meas.inten(indexes)};
                    ray.meas_points(aa,xx,yy)={meas.points(indexes,:)};
                    %place to assign summed values to (xx*yy) sized column
                    %vector
                    prev_xxnum=xx-1;
                    xxyy_ind=yy+(prev_xxnum*b);
                    trial(1).meas_inten(xxyy_ind,aa)={meas.inten(indexes)};%assign measured intensity to a row vector
                    trial(1).meas_points(xxyy_ind,aa)=ray.meas_points(aa,xx,yy);%assign measured points to a row vector
                end
            end
            
            meas_point_aa=cell2mat(trial(1).meas_points(:,aa));
            meas_inten_aa=cell2mat(trial(1).meas_inten(:,aa));
            if any(meas_inten_aa)
                disp('any')
                   [XVEC,Y, lengthPlot,pow_side_total] = Bins032725(meas_point_aa, meas_inten_aa, SystemParam.division, xLen, fiberRadius,SystemParam);
                use_index=find(meas_point_aa(:,1)>=(2.5*10^4));%indexes of all of the measurement points that correspond to measurable light after the sma
                water_st_index=find(meas_point_aa(:,1)>=SystemParam.waterStart);
                SMA_index=find(meas_point_aa(:,1)<=SystemParam.smaTotalLength);
                pow_side_use=sum(meas_inten_aa(use_index));%*(2*pi*(SystemParam.r_fib*10^-4)*((SystemParam.;
                SMA_pow_side=sum(meas_inten_aa(SMA_index));%*;
                pow_side_waterst=sum(meas_inten_aa(water_st_index));
                dAwater=((SystemParam.xLen*10^-4)-(SystemParam.waterStart*10^-4))*2*pi*(SystemParam.fiberRadius*10^-4);
                record_pow=pow_side_waterst*dAwater
                %performance metric parameters
                trial(1).Y(aa,1)=Y;
                Ylocal=cell2mat(Y);%local version of the I(x) vector
                trial(1).UC(1,aa)=Ylocal(i6)/Ylocal(i1);
            else
                incr=SystemParam.division*10^-4;
                if SystemParam.SMA==1
                    num_max = floor(((SystemParam.xLen/10e3)-(SystemParam.smaTotalLength/10e3))/(incr))+1;%dividing length of fiber by the increments, then adding one to have data at each end of bin
                
                    XVEC = zeros(1,num_max+2);    
                
                    %first two measurement points will be within the SMA flush length
                    Inc1=SystemParam.smaFlushLength*10^-4;
                    Inc2=(SystemParam.smaTotalLength-SystemParam.smaFlushLength)*10^-4;
                    
                    %first two points have irregular indexes if a part of the sma connector
                    XVEC(1)=-(Inc2+Inc1);
                    XVEC(2)=-Inc1;
                    XVEC(3:end)=0:incr:(incr*(num_max-1));
                else
                  num_max = floor((SystemParam.xLen/10e3)/(incr))+1;%dividing length of fiber by the increments, then adding one to have data at each end of bin

                    XVEC=0:incr:(incr*(num_max-1));
                end
                pow_side_total=0;
                pow_side_use=0;
                SMA_pow_side=0;
                pow_side_waterst=0;
                %performance metric parameters
                Ylocal=zeros(1,(floor((SystemParam.xLen/10e3)/(SystemParam.division/10e3))+1));%local version of the I(x) vector
                trial(1).UC(1,aa)=0;
                trial(1).Y(aa,1)={Ylocal};
            end
            %update numRandomIters storage
            %summing storage
            
            trial(1).Pow_enter(1,aa)=sum(ray.Pow_enter(aa,:,:),'all');
            trial(1).transmitted(1,aa)=sum(ray.transmitted(aa,:,:),'all');
            trans_pow=trial(1).transmitted(1,aa).*pi*(SystemParam.fiberRadius*10^-4)^2
    
            trial(1).RatioIsIt(aa,xx,yy)=trial(1).pow_side(1,aa)/trial(1).transmitted(1,aa);
            trial(1).pow_side(1,aa)=pow_side_total;
            trial(1).pow_side_use(1,aa)=pow_side_use;
            trial(1).SMA_pow_side(1,aa)=SMA_pow_side;
            trial(1).pow_side_waterst(1,aa)=pow_side_waterst;
            trial(1).absorbed(1,aa)=sum(ray.absorbed(aa,:,:),'all');
            trial(1).backscat(1,aa)=sum(ray.backscat(aa,:,:),'all');
            trial(1).SMAabs(1,aa)=sum(ray.SMAabs(aa,:,:),'all');
            trial(1).approxpow(1,aa)=sum(ray.approxpow(aa,:,:),'all');
            trial(1).approxpow_dif(1,aa)=sum(ray.approxpow_dif(aa,:,:),'all');
            trial(1).approxpow_pos(1,aa)=sum(ray.approxpow_pos(aa,:,:),'all');
            trial(1).b2hpow(1,aa)=sum(ray.b2hpow(aa,:,:),'all');
            trial(1).cutoffpow(1,aa)=sum(ray.cutoffpow(aa,:,:),'all');
            %average metrics
            trial(1).RatioIsIt(1,aa)= trial(1).pow_side_use(1,aa)./trial(1).transmitted(1,aa);
    
            
            %trial(2).Y(aa,1)={std(cell2mat(ray.Y(aa,:,:)))};          
            %actually have to calculate this one
            trial(1).remaininglosses=trial(1).Pow_enter(1,aa)-(trial(1).pow_side(1,aa)+trial(1).transmitted(1,aa)+trial(1).SMAabs(1,aa)+trial(1).b2hpow(1,aa)+trial(1).backscat+ trial(1).absorbed(1,aa)+trial(1).cutoffpow(1,aa));

            % TODO: include a place to plot instant numRandomIters
            
        end

        [FibIt, SumVal] = storeFiberResults(FibIt, SumVal, iteration, h, trial, numRandomIters);

        % TODO: Needs refreshing after data format update
        plotResults();

        if (writeToFile == 1)
            writeResults(SystemParam, description, filename, sheetNum, iteration, h, FibIt, c, legendMain, numRandomIters, LED_d, XVEC)
        end
    end

    if (sound == 1)
        load gong.mat%gong to signal the code is done handel.mat %chorus sound to signal the code is done %
        sound(y)
    end

end
% if yes_itname==1%if we need a legend bc there's multiple iterations
%     legend(legendMain)
% end

hold off

if (sound == 1)
    load gong.mat%gong to signal the code is done handel.mat %chorus sound to signal the code is done %
    sound(y)
end

